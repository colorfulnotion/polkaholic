#!/usr/bin/env node
 // Usage:

const util = require('util');
const exec = util.promisify(require("child_process").exec);
const {
    Command
} = require('commander');
const fs = require('fs');
var SubstrateETL = require("./substrateetl");
const Crawler = require("./crawler");
const ethTool = require("./ethTool");
const paraTool = require("./paraTool");

function myParseInt(value, dummyPrevious) {
    const parsedValue = parseInt(value, 10);
    if (isNaN(parsedValue)) {
        throw new commander.InvalidArgumentError('Not a number.');
    }
    return parsedValue;
}

async function main() {
    let cli_version = '0.1.0'
    const program = new Command();
    program
        .name('substrate-etl')
        .description('Manage polkaholic export to BigQuery substrate-etl project')
        .version(`${cli_version}`);


    program.command('markdumpduplicate')
        .description("Mark reload for diry partition date")
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            await substrateetl.mark_dump_duplicate();
            process.exit(0);
        });

    program.command('accounttrace')
        .description("Mark reload for diry partition date")
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            await substrateetl.accountTrace();
            process.exit(0);
        });

    program.command('dump')
        .description("Stream data out to Bigquery")
        .option('-r, --relayChain <relayChain>', 'Relay chain', null)
        .option('-p, --paraID <paraID>', 'Para ID', myParseInt)
        .option('-l, --logDT <logDT>', 'Date', null)
        .option('-e, --endDT <endDT>', 'For multi-day ranges', null)
        .option('-f, --force', `Force even if not ready`, false)
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            await substrateetl.assetManagerInit() // required for decoratedEvents
            let logDT = opt.logDT;
            let endDT = opt.logDT && opt.endDT ? opt.endDT : null;
            let paraID = opt.paraID;
            let relayChain = opt.relayChain;
            let force = opt.force;
            let dumpType = 'substrate-etl'
            if (logDT && relayChain && paraID != undefined) {
                if (endDT) {
                    let logDTRange = substrateetl.getLogDTRange(logDT, endDT)
                    console.log(`Days=${logDTRange.length} [${logDT}, ${endDT}] ->`, logDTRange)
                    for (const dt of logDTRange) {
                        if (force || (await substrateetl.is_dump_ready(dt, dumpType, {
                                relayChain,
                                paraID
                            }))) {
                            await substrateetl.dump_substrateetl(dt, paraID, relayChain);
                        }
                    }
                } else {
                    if (force || (await substrateetl.is_dump_ready(logDT, dumpType, {
                            relayChain,
                            paraID
                        }))) {
                        await substrateetl.dump_substrateetl(logDT, paraID, relayChain);
                    }
                }
                process.exit(0);
            }

            let tally = 0;
            while (true) {
                let x = await substrateetl.get_random_substrateetl(logDT, paraID, relayChain);
                let _logDT = x.logDT;
                let _paraID = x.paraID;
                let _relayChain = x.relayChain;
                tally++;
                if (_logDT && (_paraID >= 0) && _relayChain) {
                    await substrateetl.dump_substrateetl(_logDT, _paraID, _relayChain);
                    await substrateetl.sleep(1000);
                    console.log("TALLY", tally)
                    if (tally >= 25) {
                        await substrateetl.dump_substrateetl_polkaholic()
                        tally = 0;
                    }
                    if (_paraID == 0) {
                        await substrateetl.dump_xcm_range(_relayChain, null);
                        await substrateetl.update_xcm_summary(_relayChain, _logDT);
                        await substrateetl.dump_substrateetl_xcmgar(weekagoDT);
                    }
                }
                if (tally % 10 == 0) {
                    let x = await substrateetl.get_random_accountmetrics_ready(relayChain, paraID);
                    let _logDT = x.logDT;
                    let _paraID = x.paraID;
                    let _relayChain = x.relayChain;
                    tally++;
                    if (_logDT && (_paraID >= 0) && _relayChain) {
                        await substrateetl.dump_accountmetrics(_relayChain, _paraID, _logDT);
                        await substrateetl.sleep(1000);
                    } else {
                        await substrateetl.sleep(5000);
                    }
                } else {
                    await substrateetl.sleep(5000);
                }
            }
        })

    program.command('tracetally')
        .description("Stream trace data out to Bigquery")
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            await substrateetl.trace_tally();
            process.exit(0);
        });

    program.command('xcmgarudf')
        .description("Generate XCM GAR UDFs")
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            await substrateetl.generate_xcmgar_udfs();
            process.exit(0);
        });

    program.command('dumpchains')
        .description("Dump chain table")
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            await substrateetl.dump_chains();
            process.exit(0);
        });

    program.command('backfilltrace')
        .description("backfill trace data on miss")
        .option('-r, --relayChain <relayChain>', 'Relay chain', "polkadot")
        .option('-p, --paraID <paraID>', 'Para ID', null, myParseInt)
        .option('-l, --logDT <logDT>', 'Date', null)
        .option('-e, --endDT <endDT>', 'For multi-day ranges', null)
        .option('-start, --startBN <startBN>', 'startBN', null)
        .option('-end, --endBN <endBN>', 'endBN', null)
        .option('-f, --force', `Force even if not ready`, false)
        .option('-d, --desc', `Descending order`, false)
        .option('-h, --head', `Running at head`, false)
        .option('-random, --random', `Pick Random day to work on`, false)
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            //await substrateetl.init_chainInfos();
            //await substrateetl.init_asset_info();
            let [currDT, _c] = paraTool.ts_to_logDT_hr(paraTool.getCurrentTS()-900)
            let logDT = opt.logDT ? opt.logDT : "2023-03-10";
            let endDT = opt.logDT && opt.endDT ? opt.endDT : "2023-03-16";

            let startBN = opt.startBN ? paraTool.dechexToInt(opt.startBN) : null;
            let endBN = opt.startBN && opt.endBN ? paraTool.dechexToInt(opt.endBN) : null;
            if (startBN != undefined && endBN == undefined) endBN = startBN+1

            let paraID = opt.paraID ? opt.paraID : 0;
            let relayChain = opt.relayChain ? opt.relayChain : "polkadot";
            let force = opt.force;
            let isRandom = opt.random;
            let isDesc = opt.desc;
            let isHead = opt.head;
            let dumpType = 'tracebackfill';
            if (isHead){
                logDT = currDT;
                isDesc = true;
            }
            console.log(`logDT=${logDT}, endDT=${endDT}, startBN=${startBN}, endBN=${endBN}, isRandom=${isRandom}`)
            if (isRandom && relayChain && paraID != undefined){
                let tally = 0;
                while (true) {
                    let x = await substrateetl.get_random_crawl_trace_ready(relayChain, paraID);
                    let _logDT = x.logDT;
                    let _paraID = x.paraID;
                    let _relayChain = x.relayChain;
                    tally++;
                    if (_logDT && (_paraID != undefined) && _relayChain) {
                        await substrateetl.backfill_trace(_logDT, _paraID, _relayChain, false, false);
                        await substrateetl.sleep(1000);
                    } else {
                        process.exit(0);
                    }
                }
            } else if (logDT && relayChain && paraID != undefined) {
                if (startBN != null){
                    console.log(`startBN=${startBN}, endBN=${endBN}`)
                    await substrateetl.backfill_trace_range(paraID, relayChain, isDesc, isHead, startBN, endBN);
                } else if (endDT) {
                    let logDTRange = substrateetl.getLogDTRange2(logDT, endDT)
                    console.log(`Days=${logDTRange.length} ${relayChain}:${paraID} [${logDT}, ${endDT}] ->`, logDTRange)
                    for (const dt of logDTRange) {
                        if (force || (await substrateetl.is_dump_ready(dt, dumpType, {
                                relayChain,
                                paraID
                            }))) {
                            await substrateetl.backfill_trace(dt, paraID, relayChain, isDesc, isHead);
                        }
                    }
                } else {
                    if (force || (await substrateetl.is_dump_ready(dt, dumpType, {
                            relayChain,
                            paraID
                        }))) {
                        await substrateetl.backfill_trace(logDT, paraID, relayChain, isDesc, isHead);
                    }
                }
                process.exit(0);
            }
        })


    program.command('targettrace')
        .description("Dump target trace data to Bigquery")
        .option('-r, --relayChain <relayChain>', 'Relay chain', "polkadot")
        .option('-p, --paraID <paraID>', 'Para ID', null, myParseInt)
        .option('-f, --force', `Force even if not ready`, false)
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            await substrateetl.init_chainInfos();
            await substrateetl.init_asset_info();
            let paraID = opt.paraID ? opt.paraID : 0;
            let relayChain = opt.relayChain ? opt.relayChain : "polkadot";
            let force = opt.force;
            let targetBNs = await substrateetl.get_account_trace_targetBNs()
            console.log(`targetBNs(len=${targetBNs.length}), ${targetBNs}`)
            await substrateetl.dump_target_trace(paraID, relayChain, targetBNs);
            process.exit(0);
        })

    program.command('backfilltargetedtrace')
        .description("backfill targeted trace data")
        .option('-r, --relayChain <relayChain>', 'Relay chain', "polkadot")
        .option('-p, --paraID <paraID>', 'Para ID', null, myParseInt)
        .option('-f, --force', `Force even if not ready`, false)
        .option('-d, --desc', `Descending order`, false)
        .option('-h, --head', `Running at head`, false)
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            //await substrateetl.init_chainInfos();
            //await substrateetl.init_asset_info();
            let paraID = opt.paraID ? opt.paraID : 0;
            let relayChain = opt.relayChain ? opt.relayChain : "polkadot";
            let force = opt.force;
            let isDesc = opt.desc;
            let isHead = opt.head;
            let dumpType = 'tracebackfill';
            if (relayChain && paraID != undefined) {
                let targetBNs = await substrateetl.get_account_trace_targetBNs()
                console.log(`targetBNs(len=${targetBNs.length}), ${targetBNs}`)
                await substrateetl.backfill_trace_blocks(paraID, relayChain, targetBNs);
                process.exit(0);
            }
        })

    program.command('loadtrace')
        .description("load to trace table using gs decorated trace")
        .option('-r, --relayChain <relayChain>', 'Relay chain', "polkadot")
        .option('-p, --paraID <paraID>', 'Para ID', null, myParseInt)
        .option('-l, --logDT <logDT>', 'Date', null)
        .option('-e, --endDT <endDT>', 'For multi-day ranges', null)
        .option('-f, --force', `Force even if not ready`, false)
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            await substrateetl.init_chainInfos();
            await substrateetl.init_asset_info();
            let logDT = opt.logDT ? opt.logDT : "2023-03-10";
            let endDT = opt.logDT && opt.endDT ? opt.endDT : "2023-03-16";
            let paraID = opt.paraID ? opt.paraID : 0;
            let relayChain = opt.relayChain ? opt.relayChain : "polkadot";
            let force = opt.force;
            let dumpType = 'trace'
            if (logDT && relayChain && paraID != undefined) {
                    await substrateetl.loadDailyTraceFromGS(logDT, paraID, relayChain, force)
                    process.exit(0);
                }
            })


    program.command('staking')
            .description("Stream staking data out to Bigquery")
            .option('-r, --relayChain <relayChain>', 'Relay chain', "polkadot")
            .option('-p, --paraID <paraID>', 'Para ID', null, myParseInt)
            .option('-l, --logDT <logDT>', 'Date', null)
            .option('-e, --endDT <endDT>', 'For multi-day ranges', null)
            .option('-f, --force', `Force even if not ready`, false)
            .option('-random, --random', `Pick Random day to work on`, false)
            .option('-head, --head', `Work on head (Era0, Era1, Era2)`, false)

            .action(async (opt) => {
                let substrateetl = new SubstrateETL();
                await substrateetl.init_chainInfos();
                await substrateetl.init_asset_info();
                let logDT = opt.logDT ? opt.logDT : "2023-03-10";
                let endDT = opt.logDT && opt.endDT ? opt.endDT : "2023-03-16";
                let paraID = opt.paraID ? opt.paraID : 0;
                let relayChain = opt.relayChain ? opt.relayChain : "polkadot";
                let force = opt.force;
                let isHead = opt.head;
                let isRandom = opt.random;
                console.log(`force=${force}, isRandom=${isRandom}, isHead=${isHead}`)
                let dumpType = 'staking'
                if (isHead && relayChain && paraID != undefined){
                    let [prevDT, _p] = paraTool.ts_to_logDT_hr(paraTool.getCurrentTS()-86400*3);
                    let [currDT, _c] = paraTool.ts_to_logDT_hr(paraTool.getCurrentTS());
                    logDT = prevDT;
                    endDT = currDT;
                    force = true;
                    isRandom = false;
                    let chainID = paraTool.getChainIDFromParaIDAndRelayChain(paraID, relayChain);
                    await substrateetl.updateEraBlock(chainID)
                    //await substrateetl.loadFullStakingFromGS(paraID, relayChain, false)
                }
                if (isRandom && relayChain && paraID != undefined){
                    let tally = 0;
                    while (true) {
                        let x = await substrateetl.get_random_staking_ready(relayChain, paraID);
                        let _logDT = x.logDT;
                        let _paraID = x.paraID;
                        let _relayChain = x.relayChain;
                        tally++;
                        if (_logDT && (_paraID != undefined) && _relayChain) {
                            await substrateetl.dump_staking(_logDT, _paraID, _relayChain);
                            await substrateetl.sleep(1000);
                        } else {
                            process.exit(0);
                        }
                    }
                } else if (logDT && relayChain && paraID != undefined) {
                    if (endDT) {
                        let logDTRange = substrateetl.getLogDTRange2(logDT, endDT)
                        console.log(`Days=${logDTRange.length} ${relayChain}:${paraID} [${logDT}, ${endDT}] ->`, logDTRange)
                        for (const dt of logDTRange) {
                            if (force || (await substrateetl.is_dump_ready(dt, dumpType, {
                                    relayChain,
                                    paraID
                                }))) {
                                await substrateetl.dump_staking(dt, paraID, relayChain);
                            }
                        }
                    } else {
                        if (force || (await substrateetl.is_dump_ready(logDT, dumpType, {
                                relayChain,
                                paraID
                            }))) {
                            await substrateetl.dump_staking(logDT, paraID, relayChain);
                        }
                    }
                    if (isHead){
                        await substrateetl.loadFullStakingFromGS(paraID, relayChain, false)
                    }
                    process.exit(0);
                }
            })


    program.command('democracy')
            .description("Store democracy data in democracy table")
            .option('-c, --chainID <chainID>', 'Chain ID', null, myParseInt)
            .option('-l, --logDT <logDT>', 'Date', null)
            .action(async (opt) => {
                let substrateetl = new SubstrateETL();
                await substrateetl.init_chainInfos();
                await substrateetl.init_asset_info();
                let chainID = 0;
                let logDT = opt.logDT ? opt.logDT : "2023-10-29";
                await substrateetl.dump_democracy(chainID, logDT);
            })

    program.command('trace')
        .description("Stream trace data out to Bigquery")
        .option('-r, --relayChain <relayChain>', 'Relay chain', "polkadot")
        .option('-p, --paraID <paraID>', 'Para ID', null, myParseInt)
        .option('-l, --logDT <logDT>', 'Date', null)
        .option('-e, --endDT <endDT>', 'For multi-day ranges', null)
        .option('-f, --force', `Force even if not ready`, false)
        .option('-random, --random', `Pick Random day to work on`, false)
        .option('-start, --startBN <startBN>', 'startBN', null)
        .option('-end, --endBN <endBN>', 'endBN', null)
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            await substrateetl.init_chainInfos();
            await substrateetl.init_asset_info();
            let logDT = opt.logDT ? opt.logDT : "2023-03-10";
            let endDT = opt.logDT && opt.endDT ? opt.endDT : "2023-03-16";
            let paraID = opt.paraID ? opt.paraID : 0;
            let relayChain = opt.relayChain ? opt.relayChain : "polkadot";
            let force = opt.force;
            let isRandom = opt.random;
            console.log(`force=${force}, isRandom=${isRandom}`)
            let dumpType = 'trace'
            let startBN = opt.startBN ? paraTool.dechexToInt(opt.startBN) : null;
            let endBN = opt.startBN && opt.endBN ? paraTool.dechexToInt(opt.endBN) : null;
            if (startBN != undefined && endBN == undefined) endBN = startBN+1

            if (isRandom && relayChain && paraID != undefined){
                let tally = 0;
                while (true) {
                    let x = await substrateetl.get_random_trace_ready(relayChain, paraID);
                    let _logDT = x.logDT;
                    let _paraID = x.paraID;
                    let _relayChain = x.relayChain;
                    tally++;
                    if (_logDT && (_paraID != undefined) && _relayChain) {
                        await substrateetl.dump_trace(_logDT, _paraID, _relayChain);
                        await substrateetl.sleep(1000);
                    } else {
                        process.exit(0);
                    }
                }
            } else if (logDT && relayChain && paraID != undefined) {
                if (startBN != null){
                    console.log(`dump_trace_debug startBN=${startBN}, endBN=${endBN}`)
                    //await substrateetl.dump_trace_debug(paraID, relayChain, startBN, endBN);
                } else if (endDT) {
                    let logDTRange = substrateetl.getLogDTRange2(logDT, endDT)
                    console.log(`Days=${logDTRange.length} ${relayChain}:${paraID} [${logDT}, ${endDT}] ->`, logDTRange)
                    for (const dt of logDTRange) {
                        if (force || (await substrateetl.is_dump_ready(dt, dumpType, {
                                relayChain,
                                paraID
                            }))) {
                            await substrateetl.dump_trace(dt, paraID, relayChain);
                        }
                    }
                } else {
                    if (force || (await substrateetl.is_dump_ready(logDT, dumpType, {
                            relayChain,
                            paraID
                        }))) {
                        await substrateetl.dump_trace(logDT, paraID, relayChain);
                    }
                }
                process.exit(0);
            }
        })

    program.command('accountmetrics')
        .description('Dump account metrics for a chain')
        .usage("-r polkadot -p 2004 --logDT 2023-02-02")
        .option('-r, --relayChain <relayChain>', 'Relay chain', null)
        .option('-p, --paraID <paraID>', 'Para ID', myParseInt)
        .option('-l, --logDT <logDT>', 'Date', null)
        .option('-e, --endDT <endDT>', 'For multi-day ranges', null)
        .option('-f, --force', `Force even if not ready`, false)
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            let relayChain = opt.relayChain;
            let paraID = opt.paraID;
            let logDT = opt.logDT;
            let endDT = opt.logDT && opt.endDT ? opt.endDT : null;
            let force = opt.force;
            let dumpType = 'accountmetrics'
            if (logDT && paraID != null && relayChain) {
                if (endDT) {
                    let logDTRange = substrateetl.getLogDTRange(logDT, endDT)
                    console.log(`Days=${logDTRange.length} [${logDT}, ${endDT}] ->`, logDTRange)
                    for (const dt of logDTRange) {
                        if (force || (await substrateetl.is_dump_ready(dt, dumpType, {
                                relayChain,
                                paraID
                            }))) {
                            await substrateetl.dump_accountmetrics(relayChain, paraID, dt);
                        }
                    }
                } else {
                    if (force || (await substrateetl.is_dump_ready(logDT, dumpType, {
                            relayChain,
                            paraID
                        }))) {
                        await substrateetl.dump_accountmetrics(relayChain, paraID, logDT);
                    }
                }
                process.exit(0);
            }
            let tally = 0;
            while (true) {
                let x = await substrateetl.get_random_accountmetrics_ready(relayChain, paraID);
                let _logDT = x.logDT;
                let _paraID = x.paraID;
                let _relayChain = x.relayChain;
                tally++;
                if (_logDT && (_paraID >= 0) && _relayChain) {
                    await substrateetl.dump_accountmetrics(_relayChain, _paraID, _logDT);
                    await substrateetl.sleep(1000);
                } else {
                    process.exit(0);
                }
            }
        });

    program.command('crowdloan')
        .description('Dump account crowdloan using crowdloan table')
        .usage("-r polkadot --logDT 2021-10-29")
        .option('-l, --logDT <logDT>', 'Date', null)
        .option('-e, --endDT <endDT>', 'For multi-day ranges', null)
        .option('-f, --force', `Force even if not ready`, false)
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            let logDT = opt.logDT;
            let endDT = opt.logDT && opt.endDT ? opt.endDT : null;
            let force = opt.force;
            let paraID = 0
            let dumpType_step1 = 'relaychain_crowdloan'
            let dumpType_step2 = 'dotsama_crowdloan'
            let relayChains = ['polkadot', 'kusama']
            /*
            Step 1: compute relaychain_crowdloan -> this generate the relaychain.crowdloan tbl in substrate etl
            Step 2: compute dotsama_crowdloan -> this generate the dotsama.accountscrowdloan tbl in substrate etl
            */
            if (logDT) {
                if (endDT) {
                    let logDTRange = substrateetl.getLogDTRange(logDT, endDT)
                    console.log(`Days=${logDTRange.length} [${logDT}, ${endDT}] ->`, logDTRange)
                    for (const dt of logDTRange) {
                        for (const relayChain of relayChains) {
                            if (force || (await substrateetl.is_dump_ready(dt, dumpType_step1, {
                                    relayChain
                                }))) {
                                await substrateetl.dump_relaychain_crowdloan(relayChain, dt);
                            }
                        }
                        if (force || (await substrateetl.is_dump_ready(dt, dumpType_step2, {}))) {
                            await substrateetl.dump_dotsama_crowdloan(dt);
                        }
                    }
                } else {
                    for (const relayChain of relayChains) {
                        if (force || (await substrateetl.is_dump_ready(logDT, dumpType_step1, {
                                relayChain
                            }))) {
                            await substrateetl.dump_relaychain_crowdloan(relayChain, logDT);
                        }
                    }
                    if (force || (await substrateetl.is_dump_ready(logDT, dumpType_step2, {}))) {
                        await substrateetl.dump_dotsama_crowdloan(logDT);
                    }
                }
                process.exit(0);
            }

            while (true) {
                let x = await substrateetl.get_random_crowdloan_ready();
                let _logDT = x.logDT;
                if (_logDT) {
                    for (const relayChain of relayChains) {
                        if (force || (await substrateetl.is_dump_ready(logDT, dumpType_step1, {
                                relayChain
                            }))) {
                            await substrateetl.dump_relaychain_crowdloan(relayChain, _logDT);
                        }
                    }
                    if (force || (await substrateetl.is_dump_ready(_logDT, dumpType_step2, {}))) {
                        await substrateetl.dump_dotsama_crowdloan(_logDT);
                    }
                } else {
                    process.exit(0);
                }
            }
            process.exit(0);

        });

    program.command('exchange')
        .description('Dump exchange users')
        .usage("TBD")
        .option('-f, --force', `Force even if not ready`, false)
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            //await substrateetl.ingestWalletAttribution();
            await substrateetl.publishExchangeAddress('knownpubs')
            process.exit(0);
        });


    program.command('palletstorage')
        .description(`Mark pallet storage combination across chains`)
        .option('-p, --pallet <pallet>', `Pallet`, null)
        .option('-s, --storage <storage>', `Storage`, false)
        .option('--group <group>', `Storage`, null)
        .option('--groupsection <groupsection>', `Storage`, null)
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            let pallet = opt.pallet;
            let storage = opt.storage;
            let group = opt.group;
            let groupsection = opt.groupsection;
            await substrateetl.mark_pallet_storage(pallet, storage, group, groupsection);
            process.exit(0);
        });

    program.command('storage')
        .description(`Generate Storage data for a chain from trace (load subset of trace into long-term storage, key-value extraction)`)
        .usage("-l 2023-02-01 -c 2000")
        .option('-r, --relayChain <relayChain>', 'Relay chain', null)
        .option('-p, --paraID <paraID>', 'Para ID', myParseInt)
        .option('-l, --logDT <logDT>', `LogDT in YYYY-MM-DD form`, null)
        .option('-f, --force', `Force even if not ready`, true)
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            let paraID = opt.paraID;
            let relayChain = opt.relayChain;

            let logDT = opt.logDT ? opt.logDT : "2023-03-10";
            let endDT = opt.logDT && opt.endDT ? opt.endDT : "2023-03-16";
            let force = opt.force;
            let dumpType = 'storage'
            if (logDT && relayChain && paraID != undefined) {
                if (endDT) {
                    let logDTRange = substrateetl.getLogDTRange(logDT, endDT)
                    console.log(`Days=${logDTRange.length} ${relayChain} ${paraID} [${logDT}, ${endDT}] ->`, logDTRange)
                    for (const dt of logDTRange) {
                        if (force || (await substrateetl.is_dump_ready(dt, dumpType, {
                                relayChain,
                                paraID
                            }))) {
                            await substrateetl.dump_storage(relayChain, paraID, dt);
                        }
                    }
                } else {
                    if (force || (await substrateetl.is_dump_ready(logDT, dumpType, {
                            relayChain,
                            paraID
                        }))) {
                        await substrateetl.dump_storage(relayChain, paraID, logDT);
                    }
                }
                process.exit(0);
            }
        });

    program.command('updatebalances')
        .description(`Update Balances for some chain`)
        .option('-c, --chainID <chainID>', 'ChainID to update balances', null, myParseInt)
        .option('-l, --logDT <logDT>', 'Date to update', null)
        .option('-e, --endDT <endDT>', 'For multi-day ranges', null)
        .option('--startTS <startTS>', 'To resume long-running update balances', null)
        .action(async (opt) => {
            let chainID = opt.chainID != null ? opt.chainID : null;
            let logDT = opt.logDT ? opt.logDT : null;
            let endDT = opt.logDT && opt.endDT ? opt.endDT : null;

            if (chainID != null && logDT) {
                if (endDT && logDT) {
                    var manager = new SubstrateETL();
                    let done = false;
                    let logDTRange = manager.getLogDTRange(logDT, endDT)
                    console.log(`Days=${logDTRange.length} [${logDT}, ${endDT}] ->`, logDTRange)
                    for (const dt of logDTRange) {
                        let startTS = manager.getCurrentTS();
                        await manager.updateAddressBalances(chainID, dt, true);
                        //TODO: review the startTS?
                    }
                    process.exit(0);
                } else if (logDT) {
                    var manager = new SubstrateETL();
                    let done = false;
                    do {
                        done = await manager.updateAddressBalances(chainID, logDT, true);
                        //await manager.sleep(5000);
                    } while (!done)
                    if (!done) {
                        console.log(`manually resume: ./substrate-etl -c ${chainID} -l ${logDT} --startTS ${startTS}`);
                    }
                    process.exit(0);
                }
            } else {
                var manager = new SubstrateETL();
                while (1) {
                    let res = await manager.updateAddressBalances(chainID);
                    if (res == false) {
                        const gbRounded = manager.gb_heap_used();
                        if (gbRounded > .8) {
                            process.exit(1);
                        }
                    }
                    await manager.sleep(5000);
                }
            }
        });

    program.command('contracts')
        .description(`Update Contracts for (2006-astar, 2094-pendulum, 22007-shiden, 22124-amplitude, 30000-shibuya, 40000-rococo`)
        .option('-c, --chainID <chainID>', 'ChainID to update contracts', null, myParseInt)
        .action(async (opt) => {
            var manager = new SubstrateETL();
            let chainID = opt.chainID != null ? opt.chainID : null;
            if (chainID != null) {
                await manager.updateContracts(chainID)
                process.exit(0);
            } else {
                await manager.assetManagerInit()
                await manager.dumpContracts()
                process.exit(0);
            }
        });


    program.command('cleanreaped')
        .description(`For any reaped account balances, deletes old cells more than 48 hours old from a random or specified shard`)
        .option('-s, --shard <shard>', `Shard [0..15]`, null)
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            await substrateetl.cleanReaped(opt.shard);
            process.exit(0);
        });

    program.command('blocklog')
        .description(`Crawl Chain for any missing blocks`)
        .option('-c, --chainID <chainID>', 'ChainID', myParseInt)
        .option('-l, --logDT <logDT>', 'Date to recompute blocklog')
        .action(async (opt) => {
            var substrateetl = new SubstrateETL();
            if (opt.logDT && opt.chainID) {
                await substrateetl.update_blocklog(opt.chainID, opt.logDT);
            } else if (opt.chainID) {
                await substrateetl.update_blocklog_bulk(opt.chainID);
            } else {
                await substrateetl.updateBlocklogBulk();
                await substrateetl.sleep(1000);
            }
            process.exit(0);
        });

    program.command('audit_fix')
        .description("Detect chain issues")
        .option('-c, --chainID <chainID>', 'ChainID', myParseInt)
        .option('-m', 'model chain issues', false)
        .action(async (opt) => {
            var substrateetl = new SubstrateETL();
            if (opt.m) {
                await substrateetl.detectChainIssues(opt.chainID);
            } else {
                await substrateetl.audit_fix(opt.chainID);
            }
            process.exit(0);
        })

    program.command('auditblocks')
        .description("Audit blocks")
        .usage("-c 2004")
        .option('-c, --chainID <chainID>', 'ChainID', myParseInt, null)
        .option('-m, --monthDT <monthDT>', 'ChainID', null)
        .action(async (opt) => {
            var substrateetl = new SubstrateETL();
            await substrateetl.audit_blocks(opt.chainID, opt.monthDT);
            process.exit(0);
        })

    program.command('xcm')
        .usage("polkadot -l 2023-02-01")
        .description("Dump xcm + xcm transfers of relay chain")
        .argument('<relayChain>', 'Relay chain (polkadot or kusama)')
        .option("-l, --logDT <logDT>", "Oldest date to dump", null)
        .action(async (relayChain, opt) => {
            var substrateetl = new SubstrateETL();
            let [weekagoDT, _] = paraTool.ts_to_logDT_hr(substrateetl.getCurrentTS() - 86400 * 7);
            let logDT = opt.logDT ? opt.logDT : weekagoDT;
            await substrateetl.dump_xcm_range(relayChain, logDT);
            await substrateetl.update_xcm_summary(relayChain, logDT);
            process.exit(0);
        })

    program.command('polkaholic')
        .description("Dump polkaholic.json (for export)")
        .option("-f, --fix", "Fix gaps", false)
        .action(async (opt) => {
            var substrateetl = new SubstrateETL();
            let fix = opt.fix;
            await substrateetl.dump_substrateetl_polkaholic(fix)
            process.exit(0);
        })

    program.command('xcmgar')
        .description("Dump chains, assets + xcmassets data")
        .action(async (opt) => {
            var substrateetl = new SubstrateETL();
            await substrateetl.dump_substrateetl_xcmgar()
            process.exit(0);
        })

    program.command('setupsubstrate')
        .description("Setup or update BigQuery tables for relaychain/paraID. Use -u to update tbl schema")
        .usage("2002")
        .option('-c, --chainID <chainID>', 'ChainID', null)
        .option('-u, --update', `update schema mode`, false)
        //.argument('<chainID>', 'Chain ID', myParseInt)
        .action(async (opt) => {
            var substrateetl = new SubstrateETL();
            let chainID = opt.chainID
            let isUpdate = (opt.update) ? true : false
            let isAll = (opt.all) ? true : false
            if (chainID != undefined) chainID = myParseInt(chainID)
            await substrateetl.setup_chain_substrate(chainID, isUpdate);
            process.exit(0);
        })

    program.command('showtables')
        .usage("-f accounts")
        .description(`Show all substrate etl tables`)
        .option('-f, --filter <filter>', `filter to use`, 'NA')
        .action(async (opt) => {
            let substrateetl = new SubstrateETL();
            let {
                filter
            } = opt;
            if (filter == "NA") filter = ''
            let fullTableIDs = await substrateetl.getAlltables(filter)
            console.log(`Matched Table[${fullTableIDs.length}]`)
            for (const fullTableID of fullTableIDs) {
                console.log(fullTableID)
            }
            process.exit(0);
        });

    program.command('callevents')
        .description(`Generate schemas for calls+events`)
        .action(async (opt) => {
            var substrateetl = new SubstrateETL();
            await substrateetl.setupCallEvents();
            process.exit(0);
        });

    program.command('labels')
        .description(`Generate labels for account dashboards`)
        .action(async (opt) => {
            var substrateetl = new SubstrateETL();
            await substrateetl.update_account_labels();
            process.exit(0);
        });

    program.command('deletetables')
        .usage("-f accounts")
        .description(`Generate delete cmd for matching substarte etl tables (Note: will only generate commands, you must manually run them)`)
        .option('-f, --filter <filter>', `filter to use`, 'NA')
        .action(async (opt) => {
            var substrateetl = new SubstrateETL();
            let {
                filter
            } = opt;
            if (filter == "NA") {
                console.log("NOT ALLOWED")
                process.exit(1)
            }
            //var substrateetl = new SubstrateETL();
            let fullTableIDs = await this.getAlltables(filter)
            let bqCmds = []
            for (const fullTableID of fullTableIDs) {
                let bqCmd = `bq rm -f ${fullTableID}`
                bqCmds.push(bqCmd)
                console.log(bqCmd)
            }
            process.exit(0);
        });

    await program.parseAsync(process.argv);
}

main()
    .then(() => {
        // do not process.exit(0) here
    })
    .catch((e) => {
        console.error('ERROR', e);
        process.exit(1);
    });
