#!/usr/bin/env node
 // Usage:
//  setup tables:                       dumpSubstrateETL polkadot setup paraID
//    sets up dataset for all known paraIDs using substateetllog table
//  dump all chains:                    dumpSubstrateETL polkadot chains
//  dump random paraID for a day:       dumpSubstrateETL
//    This uses the "substateetllog.loaded" field to choose a logDT/paraID/relayChain
//  dump paraID 2000 for specific day:  dumpSubstrateETL polkadot 2000 2022-12-29
//  dump all xcmtransfers for a day:    dumpSubstrateETL polkadot xcmtransfers 2022-12-29
//  dump all xcmtransfers in last year: dumpSubstrateETL polkadot xcmtransfers
//  dump account matrics in last year: dumpSubstrateETL polkadot accountmatrics
//  compute xcmteleporfees: dumpSubstrateETL polkadot xcmteleportfees
//  update blocklog: dumpSubstrateETL blocklog
//  update blocklog: dumpSubstrateETL polkaholic

var SubstrateETL = require("./substrateetl");

async function main() {
    let relayChain = null;
    let paraID = -1;
    let logDT = null;
    let isEVM = 0;

    process.argv.forEach(function(val, index, array) {
        if (index == 2 && val.length > 0) {
            relayChain = val;
        }
        if (index == 3 && val.length > 0) {
            // TODO: use flags pkg instead
            if (val == "xcmtransfers" || val == "chains" || val == "setup" || val == "xcmteleportfees" || val == "blocklog" || val == "blocklogstats" || val == "auditblocks" || val == "accountmatrics") {
                paraID = val;
            } else {
                paraID = parseInt(val, 10);
            }
        }
        if (index == 4 && val.length > 0) {
            logDT = val;
        }
        if (index == 5 && val.length > 0) {
            isEVM = parseInt(val, 10);
        }
    });

    // TODO: use commander instead of this...
    var substrateetl = new SubstrateETL();
    if (paraID == "setup" && relayChain) {
        await substrateetl.setup_tables(relayChain, logDT);
    } else if (paraID == "xcmteleportfees" && relayChain) {
        let logDT = "2023-01-01"; // TODO
        await substrateetl.compute_teleportfees(relayChain, logDT);
    } else if (relayChain == "blocklog") {
        await substrateetl.updateBlocklogBulk(paraID) // actually chainID
    } else if (relayChain == "auditfix") {
        await substrateetl.audit_fix(paraID); // actually chainID
    } else if (relayChain == "auditblocks") {
        await substrateetl.audit_blocks(paraID); // actually chainID
    } else if (relayChain == "polkaholic") {
        await substrateetl.dump_substrateetl_polkaholic()
    } else if (paraID == "xcmtransfers" && relayChain) {
        if (logDT) {
            await substrateetl.dump_xcmtransfers(logDT, relayChain);
        } else {
            await substrateetl.dump_xcmtransfers_range(relayChain, null);
        }
    } else if (paraID == "accountmatrics" && relayChain) {
        if (logDT) {
            await substrateetl.dump_account_matrics(logDT, relayChain);
        } else {
            await substrateetl.dump_account_matrics_range(relayChain, null);
        }
    } else if (paraID == "chains" && relayChain) {
        await substrateetl.dump_chains(relayChain);
    } else if (paraID >= 0 && logDT && relayChain) {
        await substrateetl.dump_substrateetl(logDT, paraID, relayChain, isEVM);
    } else {
        let tally = 0;
        while (true) {
            let x = await substrateetl.get_random_substrateetl(logDT, paraID, relayChain);
            let _logDT = x.logDT;
            let _paraID = x.paraID;
            let _relayChain = x.relayChain;
            let _isEVM = x.isEVM;
            if (_logDT && (_paraID >= 0) && _relayChain) {
                await substrateetl.dump_substrateetl(_logDT, _paraID, _relayChain, _isEVM);
                await substrateetl.sleep(1000);
                tally++;
                if (tally > 25) {
                    await substrateetl.dump_substrateetl_polkaholic()
                    tally = 0;
                }
            } else {
                await substrateetl.sleep(10000);
            }
        }
    }
}

main()
    .then(() => {
        console.log("finishing...")
        process.exit(0);
    })
    .catch((e) => {
        console.error('ERROR', e);
        process.exit(1);
    });
