#!/usr/bin/env node
const {
    Command
} = require('commander');
var EVMETL = require("./evmetl");

function myParseInt(value, dummyPrevious) {
    const parsedValue = parseInt(value, 10);
    if (isNaN(parsedValue)) {
        throw new commander.InvalidArgumentError('Not a number.');
    }
    return parsedValue;
}

async function main() {
    let cli_version = '0.1.0'
    const program = new Command();
    program
        .name('evm-etl')
        .description('Manage polkaholic export to BigQuery substrate-etl project')
        .version(`${cli_version}`);

    program.command('crawlabi')
        .description(`Get ABI for contract from external API (Etherscan, ...) based on chainID`)
        .option('-c, --chainID <chainID>', 'ChainID to update balances', myParseInt, 1)
        .option('-p, --project <project>', 'Project Name (e.g. wormhole)', "")
        .option('-n, --contractName <contractName>', 'Contract Name (e.g. Endpoint)', "")
        .argument('<address>', 'Contract Address')
        .action(async (address, opt) => {
            let chainID = opt.chainID != null ? opt.chainID : 1;
            let project = opt.project ? opt.project : null;
            let contractName = opt.contractName ? opt.contractName : null;
	    let evmetl = new EVMETL();
	    await evmetl.crawlABI(address, chainID, project, contractName);
	    process.exit(0);
        });

    program.command('crawlabis')
        .description(`Get New ABIs`)
        .option('-c, --chainID <chainID>', 'ChainID to crawl ABIs', myParseInt, null)
        .action(async (opt) => {
	    console.log(opt);
	    let evmetl = new EVMETL();
	    await evmetl.crawlABIs(opt.chainID);
	    process.exit(0);
        });

    program.command('loadabi')
        .description(`Get ABI for contract`)
        .argument('<abistr>', 'Contract Address')
        .action(async (abistr, opt) => {
	    let evmetl = new EVMETL();
	    await evmetl.loadABI(abistr);
	    process.exit(0);
        });

    program.command('loadabirepo')
        .description(`Load ABI Repo into BigQuery`)
        .action(async (abistr, opt) => {
	    let evmetl = new EVMETL();
	    await evmetl.loadABIRepo();
	    process.exit(0);
        });

    program.command('learnmethod')
        .description(`Learn method`)
        .option('-c, --chainID <chainID>', 'ChainID to pick examples from', myParseInt, null)
        .option('-a, --address <address>', 'Address to pick examples from', "")
        .action(async (abistr, opt) => {
	    let evmetl = new EVMETL();
	    await evmetl.learnMethod(opt.chainID, opt.address);
	    process.exit(0);
        });

    program.command('addcontracttype')
        .description(`Add Contract Type ABI for contract`)
        .argument('<contractType>', 'Contract Address')
        .argument('<abistr>', 'Contract Address')
        .action(async (contractType, abistr, opt) => {
	    let evmetl = new EVMETL();
	    await evmetl.addContractType(contractType, abistr);
	    process.exit(0);
        });

    program.command('contracttypes')
        .description(`Update Contract Types`)
        .action(async (opt) => {
	    console.log(opt);
	    let evmetl = new EVMETL();
	    await evmetl.updateContractTypes(opt.chainID);
	    process.exit(0);
        });

    program.command('reloadabi')
        .description(`Reload ABI`)
        .option('-s, --sql <targetSQL>', 'Target SQL', null)
        .action(async (abistr, opt) => {
            let evmetl = new EVMETL();
            await evmetl.reloadABI(opt.sql);
            process.exit(0);
        });
    
    program.command('setupevm')
        .description("Setup or update BigQuery tables for EVM Chain. Use -u to update tbl schema")
        .usage("-c 137")
        .option('-c, --chainID <chainID>', 'ChainID', null)
        .option('-u, --update', `update schema mode`, false)
        .action(async (opt) => {
            var substrateetl = new SubstrateETL();
            let chainID = opt.chainID
            let isUpdate = (opt.update) ? true : false
            let isAll = (opt.all) ? true : false
            if (chainID != undefined) chainID = myParseInt(chainID)
            await evmetl.setup_chain_evm(chainID, isUpdate);
            process.exit(0);
        })


    program.command('setupdataset')
        .description("Setup dataset in substrate-etl")
        .usage("-d evm_dev")
        .option('-d, --datasetID <datasetID>', 'datasetID', 'evm_dev')
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let datasetID = opt.datasetID
            await evmetl.setup_dataset(datasetID);
            process.exit(0);
    })

    program.command('deletedataset')
        .description("Delete dataset in substrate-etl")
        .usage("-d evm_dev")
        .option('-d, --datasetID <datasetID>', 'datasetID', 'evm_dev')
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let datasetID = opt.datasetID
            await evmetl.delete_dataset(datasetID);
            process.exit(0);
    })

    program.command('abianalytics')
        .description(`Reload ABIs`)
        .action(async (abistr, opt) => {
	    let evmetl = new EVMETL();
	    await evmetl.abiAnalytics();
	    process.exit(0);
        });

    program.command('callevents')
        .description(`Generate schemas for calls+events`)
        .option('-c, --create', `crate table schema mode`, false)
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let isCreate = (opt.create) ? true : false
	        await evmetl.setupCallEvents(isCreate);
            process.exit(0);
        });

    program.command('loadlabels')
	.argument('<chainID>', 'Address')
        .argument('<fileName>', `Storage Slot`)
        .action(async (chainID, fileName, opt) => {
            var evmetl = new EVMETL();
	    await evmetl.loadLabels(chainID, fileName);
            process.exit(0);
        });

    program.command('getStorageAt')
        .description(`run getStorageAt`)
	.argument('<address>', 'Address')
        .argument('<storageSlot>', `Storage Slot`)
	.option('-c, --chainID <chainID>', 'Address', 1)
        .action(async (address, storageSlot, opt) => {
            var evmetl = new EVMETL();
	    let res = await evmetl.getStorageAt(storageSlot, address, opt.chainID);
	    console.log(res);
            process.exit(0);
        });

    await program.parseAsync(process.argv);
}

main()
    .then(() => {
        // do not process.exit(0) here
    })
    .catch((e) => {
        console.error('ERROR', e);
        process.exit(1);
    });
