#!/usr/bin/env node

const {
    Command
} = require('commander');
var EVMETL = require("./evmetl");
const paraTool = require("./paraTool");


function myParseInt(value, dummyPrevious) {
    const parsedValue = parseInt(value, 10);
    if (isNaN(parsedValue)) {
        throw new commander.InvalidArgumentError('Not a number.');
    }
    return parsedValue;
}

async function main() {
    let cli_version = '0.1.0'
    const program = new Command();
    program
        .name('evm-etl')
        .description('Manage polkaholic export to BigQuery substrate-etl project')
        .version(`${cli_version}`);

    program.command('crawlabi')
        .description(`Get ABI for contract from external API (Etherscan, ...) based on chainID`)
        .option('-c, --chainID <chainID>', 'ChainID to update balances', myParseInt, paraTool.chainIDEthereum)
        .option('-p, --project <project>', 'Project Name (e.g. wormhole)', "")
        .option('-n, --contractName <contractName>', 'Contract Name (e.g. Endpoint)', "")
        .argument('<address>', 'Contract Address')
        .action(async (address, opt) => {
            let chainID = opt.chainID != null ? opt.chainID : paraTool.chainIDEthereum;
            let project = opt.project ? opt.project : null;
            let contractName = opt.contractName ? opt.contractName : null;
            let evmetl = new EVMETL();
            await evmetl.crawlABI(address, chainID, project, contractName);
            process.exit(0);
        });

    program.command('generateproject')
        .description(`Get ABI for contract from external API (Etherscan, ...) based on chainID`)
        .option('-c, --chainID <chainID>', 'ChainID to update balances', myParseInt, paraTool.chainIDEthereum)
        .option('-p, --project <project>', 'Project Name (e.g. wormhole)', "")
        .option('-n, --contractName <contractName>', 'Contract Name (e.g. Endpoint)', "")
        .argument('<address>', 'Contract Address')
        .action(async (address, opt) => {
            let chainID = opt.chainID != null ? opt.chainID : paraTool.chainIDEthereum;
            let project = opt.project ? opt.project : null;
            let contractName = opt.contractName ? opt.contractName : null;
            let evmetl = new EVMETL();
            await evmetl.initEvmSchemaMap()
            await evmetl.generateProject(address, chainID, project, contractName);
            process.exit(0);
        });

    program.command('createdatasetschema')
        .description(`Auto generate dataset table schemas`)
        .option('-p, --projectID <projectID>', 'projectID (e.g. substrate-etl)', "substrate-etl")
        .argument('<datasetID>', 'datasetID (e.g. crypto_ethereum)')
        .action(async (datasetID, opt) => {
            let projectID = opt.projectID ? opt.projectID : null;
            let evmetl = new EVMETL();
            await evmetl.createDatasetSchema(datasetID, projectID);
            process.exit(0);
        });

    program.command('crawlabis')
        .description(`Get New ABIs`)
        .option('-c, --chainID <chainID>', 'ChainID to crawl ABIs', myParseInt, null)
        .action(async (opt) => {
            console.log(opt);
            let evmetl = new EVMETL();
            await evmetl.crawlABIs(opt.chainID);
            process.exit(0);
        });

    program.command('loadabi')
        .description(`Get ABI for contract`)
        .argument('<abistr>', 'Contract Address')
        .action(async (abistr, opt) => {
            let evmetl = new EVMETL();
            await evmetl.loadABI(abistr);
            process.exit(0);
        });

    program.command('loadabirepo')
        .description(`Load ABI Repo into BigQuery`)
        .action(async (abistr, opt) => {
            let evmetl = new EVMETL();
            await evmetl.loadABIRepo();
            process.exit(0);
        });

    program.command('asset_platforms')
        .description(`Fetch Asset Platforms (from coingecko)`)
        .action(async (opt) => {
            var PriceManager = require("./priceManager");
            let pm = new PriceManager();
            await pm.update_coingecko_asset_platforms();
            process.exit(0);
        });

    program.command('priceusd')
        .description(`Fetch Price USD (from coingecko)`)
        .action(async (opt) => {
            var PriceManager = require("./priceManager");
            let pm = new PriceManager();
            await pm.update_coingecko_token_price_usd();
            process.exit(0);
        });

    program.command('addcontracttype')
        .description(`Add Contract Type ABI for contract`)
        .argument('<contractType>', 'Contract Address')
        .argument('<abistr>', 'Contract Address')
        .action(async (contractType, abistr, opt) => {
            let evmetl = new EVMETL();
            await evmetl.addContractType(contractType, abistr);
            process.exit(0);
        });

    program.command('contracttypes')
        .description(`Update Contract Types`)
        .action(async (opt) => {
            console.log(opt);
            let evmetl = new EVMETL();
            await evmetl.updateContractTypes(opt.chainID);
            process.exit(0);
        });

    program.command('reloadabi')
        .description(`Reload ABI`)
        .option('-s, --sql <targetSQL>', 'Target SQL', null)
        .action(async (abistr, opt) => {
            let evmetl = new EVMETL();
            await evmetl.reloadABI(opt.sql);
            process.exit(0);
        });

    program.command('setupevm')
        .description("Setup or update BigQuery tables for EVM Chain. Use -u to update tbl schema")
        .usage("-c 137")
        .option('-c, --chainID <chainID>', 'ChainID to create dataset for', myParseInt, paraTool.chainIDPolygon)
        .option('-u, --update', `update schema mode`, false)
        .action(async (opt) => {
            let chainID = opt.chainID != null ? opt.chainID : paraTool.chainIDPolygon;
            let isUpdate = (opt.update) ? true : false
            let isAll = (opt.all) ? true : false
            if (chainID != undefined) chainID = myParseInt(chainID)
            let evmetl = new EVMETL();

            let dotsamaEvmChains = [paraTool.chainIDAcala, paraTool.chainIDKarura, paraTool.chainIDMoonbeam, paraTool.chainIDClover, paraTool.chainIDAstar, paraTool.chainIDMoonriver, paraTool.chainIDShiden]
            if (dotsamaEvmChains.includes(dotsamaEvmChains)) {
                process.exit(1, "Use evm chainID to setup dataset");
            } else {
                await evmetl.setup_chain_evm(chainID, isUpdate);
            }
            process.exit(0);
        })


    program.command('setupdataset')
        .description("Setup dataset in substrate-etl")
        .usage("-d evm_dev")
        .option('-d, --datasetID <datasetID>', 'datasetID', 'evm_dev')
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let datasetID = opt.datasetID
            await evmetl.setup_dataset(datasetID);
            process.exit(0);
        })

    program.command('deletedataset')
        .description("Delete dataset in substrate-etl")
        .usage("-d evm_dev")
        .option('-d, --datasetID <datasetID>', 'datasetID', 'evm_dev')
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let datasetID = opt.datasetID
            await evmetl.delete_dataset(datasetID);
            process.exit(0);
        })

    program.command('abianalytics')
        .description(`Reload ABIs`)
        .action(async (abistr, opt) => {
            let evmetl = new EVMETL();
            await evmetl.abiAnalytics();
            process.exit(0);
        });

    program.command('callevents')
        .description(`Generate schemas for calls+events`)
        .option('-c, --create', `crate table schema mode`, false)
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let isCreate = (opt.create) ? true : false
            await evmetl.setupCallEvents(isCreate);
            process.exit(0);
        });

    program.command('loadlabels')
        .argument('<chainID>', 'Address')
        .argument('<fileName>', `Storage Slot`)
        .action(async (chainID, fileName, opt) => {
            var evmetl = new EVMETL();
            await evmetl.loadLabels(chainID, fileName);
            process.exit(0);
        });

    program.command('getStorageAt')
        .description(`run getStorageAt`)
        .argument('<address>', 'Address')
        .argument('<storageSlot>', `Storage Slot`)
        .option('-c, --chainID <chainID>', 'Address', 1)
        .action(async (address, storageSlot, opt) => {
            var evmetl = new EVMETL();
            let res = await evmetl.getStorageAt(storageSlot, address, opt.chainID);
            console.log(res);
            process.exit(0);
        });

    program.command('projects')
        .action(async (address, storageSlot, opt) => {
            var evmetl = new EVMETL();
            await evmetl.modelProjects();
            process.exit(0);
        });

    program.command('project')
        .option('-a, --abiType <abiType>', "event")
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let abiType = opt.abiType ? opt.abiType : "event";
            await evmetl.enrich_projectcontractabi(abiType);
            process.exit(0);
        });

    program.command('generateevmschema')
        .action(async () => {
            var evmetl = new EVMETL();
            await evmetl.generateTableSchemaJSON();
            process.exit(0);
        });


    program.command('dryrun')
        .argument('<query>', `Query`)
        .action(async (query) => {
            var evmetl = new EVMETL();
            await evmetl.dryrun(query);
            process.exit(0);
        });

    program.command('projectschema')
        .option('-d, --datasetId <datasetId>', "Model datasetID", null)
        .option('-p, --project <projectId>', "Model project", null)
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let datasetId = opt.datasetId ? opt.datasetId : null;
            let projectId = opt.projectId ? opt.projectId : "blockchain-etl";
            await evmetl.load_project_schema(datasetId, projectId);
            process.exit(0);
        });

    program.command('projectroutines')
        .option('-d, --datasetId <datasetId>', "Model datasetID", null)
        .option('-p, --project <projectId>', "Model project", null)
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let datasetId = opt.datasetId ? opt.datasetId : null;
            let projectId = opt.projectId ? opt.projectId : "blockchain-etl-internal";
            await evmetl.load_project_routines(datasetId, projectId);
            process.exit(0);
        });


    /* Regnerate One day worth of data

    Step0 create blocklog rec
    Step1 ./evm-etl cpblk -l 2023-05-12
    Step2 ./evm-etl backfill -c 1 -l 2023-05-12
    Step3 ./evm-etl indexchain -c 1 -l 2023-05-12
    Step4 ./evm-etl cpevmdecoded -c 1 -l 2023-05-12
    Step5 ./evm-etl loadevmdecoded -l 2023-05-12

    */

    program.command('processchainsteps')
        .description(`process a full day of chain data`)
        .option('-c, --chainID <chainID>', 'ChainID to cpoy', myParseInt, paraTool.chainIDEthereum)
        .option('-l, --logDT <logDT>', 'Date', null)
        .option('-e, --endDT <endDT>', 'For multi-day ranges', null)
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let [prevDT, _c] = paraTool.ts_to_logDT_hr(evmetl.getCurrentTS() - 86400 - 3600)
            let chainID = opt.chainID ? opt.chainID : paraTool.chainIDEthereum;
            let logDT = opt.logDT ? opt.logDT : prevDT;
            let endDT = opt.logDT && opt.endDT ? opt.endDT : null;
            if (logDT) {
                if (endDT) {
                    let logDTRange = evmetl.getLogDTRange(logDT, endDT)
                    for (const dt of logDTRange) {
                        await evmetl.processChainSteps(dt, chainID);
                    }
                } else {
                    await evmetl.processChainSteps(logDT, chainID);
                }
            }
            process.exit(0);
        });


    program.command('cpblk')
        .option('-c, --chainID <chainID>', 'ChainID to cpoy', myParseInt, paraTool.chainIDEthereum)
        .option('-l, --logDT <logDT>', 'Date', null)
        .option('-e, --endDT <endDT>', 'For multi-day ranges', null)
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let chainID = opt.chainID ? opt.chainID : paraTool.chainIDEthereum;
            let logDT = opt.logDT ? opt.logDT : "2023-04-01";
            let endDT = opt.logDT && opt.endDT ? opt.endDT : null;
            if (logDT) {
                if (endDT) {
                    let logDTRange = evmetl.getLogDTRange(logDT, endDT)
                    for (const dt of logDTRange) {
                        await evmetl.cpblk(dt, chainID);
                    }
                } else {
                    await evmetl.cpblk(logDT, chainID);
                }
            }
            process.exit(0);
        });

    program.command('backfill')
        .option('-c, --chainID <chainID>', 'ChainID to backfill', myParseInt, paraTool.chainIDEthereum)
        .option('-l, --logDT <logDT>', 'Date', null)
        .option('-e, --endDT <endDT>', 'For multi-day ranges', null)
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let chainID = opt.chainID ? opt.chainID : paraTool.chainIDEthereum;
            let logDT = opt.logDT ? opt.logDT : "2023-04-01";
            let endDT = opt.logDT && opt.endDT ? opt.endDT : null;
            if (logDT) {
                if (endDT) {
                    let logDTRange = evmetl.getLogDTRange(logDT, endDT)
                    for (const dt of logDTRange) {
                        await evmetl.backfill(dt, chainID);
                    }
                } else {
                    await evmetl.backfill(logDT, chainID);
                }
            }
            process.exit(0);
        });

    program.command('indexevmchain')
        .option('-c, --chainID <chainID>', 'ChainID to Index', myParseInt, paraTool.chainIDEthereum)
        .option('-l, --logDT <logDT>', 'Date', null)
        .option('-e, --endDT <endDT>', 'For multi-day ranges', null)
        .option('-f, --force', `Force even it's already processed`, false)
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let [prevDT, _c] = paraTool.ts_to_logDT_hr(evmetl.getCurrentTS() - 86400 - 1800)
            let chainID = opt.chainID ? opt.chainID : paraTool.chainIDEthereum;
            let logDT = opt.logDT ? opt.logDT : prevDT;
            let endDT = opt.logDT && opt.endDT ? opt.endDT : null;
            let force = opt.force;
            if (logDT) {
                if (endDT) {
                    let logDTRange = evmetl.getLogDTRange(logDT, endDT, force)
                    for (const dt of logDTRange) {
                        await evmetl.index_evmchain_external(chainID, dt, force);
                    }
                } else {
                    await evmetl.index_evmchain_external(chainID, logDT, force);
                }
            }
            process.exit(0);
        });

    program.command('copyevmdecoded')
        .option('-c, --chainID <chainID>', 'ChainID to Copy result into gs bucket: gs://evm_decoded/', myParseInt, paraTool.chainIDEthereum)
        .option('-l, --logDT <logDT>', 'Date', null)
        .option('-e, --endDT <endDT>', 'For multi-day ranges', null)
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let [prevDT, _c] = paraTool.ts_to_logDT_hr(evmetl.getCurrentTS() - 86400 - 3600)
            let chainID = opt.chainID ? opt.chainID : paraTool.chainIDEthereum;
            let logDT = opt.logDT ? opt.logDT : prevDT;
            let endDT = opt.logDT && opt.endDT ? opt.endDT : null;
            if (logDT) {
                if (endDT) {
                    let logDTRange = evmetl.getLogDTRange(logDT, endDT)
                    for (const dt of logDTRange) {
                        await evmetl.cpEvmDecodedToGS(dt, chainID);
                    }
                } else {
                    await evmetl.cpEvmDecodedToGS(logDT, chainID);
                }
            }
            process.exit(0);
        });

    //loadevmdecoded cannot support chainID-specific update
    program.command('loadevmdecoded')
        //.option('-c, --chainID <chainID>', 'ChainID to load result', myParseInt, paraTool.chainIDEthereum)
        .option('-l, --logDT <logDT>', 'Date', null)
        .option('-e, --endDT <endDT>', 'For multi-day ranges', null)
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let [prevDT, _c] = paraTool.ts_to_logDT_hr(evmetl.getCurrentTS() - 86400 - 3600)
            let logDT = opt.logDT ? opt.logDT : prevDT;
            let endDT = opt.logDT && opt.endDT ? opt.endDT : null;
            if (logDT) {
                if (endDT) {
                    let logDTRange = evmetl.getLogDTRange(logDT, endDT)
                    for (const dt of logDTRange) {
                        await evmetl.loadGSEvmDecoded(dt);
                    }
                } else {
                    await evmetl.loadGSEvmDecoded(logDT);
                }
            }
            process.exit(0);
        });

    program.command('preloadevmschema')
        .action(async (opt) => {
            var evmetl = new EVMETL();
            await evmetl.preloadEvmSchema();
        });

    program.command('updateevmschema')
        .action(async (opt) => {
            var evmetl = new EVMETL();
            await evmetl.updateEvmschema();
        });

    program.command('views')
        .action(async (opt) => {
            var evmetl = new EVMETL();
            await evmetl.loadProjectViews();
        });

    program.command('blocklogbounds')
        .option('-c, --chainID <chainID>', 'ChainID to bound', myParseInt, paraTool.chainIDEthereum)
        .option('-l, --logDT <logDT>', 'Date', null)
        .option('-e, --endDT <endDT>', 'For multi-day ranges', null)
        .action(async (opt) => {
            var evmetl = new EVMETL();
            let [prevDT, _c] = paraTool.ts_to_logDT_hr(evmetl.getCurrentTS() - 86400 - 60)
            let chainID = opt.chainID;
            let logDT = opt.logDT ? opt.logDT : prevDT;
            let endDT = opt.logDT && opt.endDT ? opt.endDT : null;
            await evmetl.detectBlocklogBounds(chainID, logDT);
            process.exit(0);
        });

    await program.parseAsync(process.argv);
}

main()
    .then(() => {
        // do not process.exit(0) here
    })
    .catch((e) => {
        console.error('ERROR', e);
        process.exit(1);
    })
