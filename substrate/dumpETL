#!/usr/bin/env node
 // Usage:
//  setup tables:                       dumpSubstrateETL polkadot setup paraID
//    sets up dataset for all known paraIDs using substateetllog table
//  dump all chains:                    dumpSubstrateETL polkadot chains
//  dump random paraID for a day:       dumpSubstrateETL
//    This uses the "substateetllog.loaded" field to choose a logDT/paraID/relayChain
//  dump paraID 2000 for specific day:  dumpSubstrateETL polkadot 2000 2022-12-29
//  dump all xcmtransfers for a day:    dumpSubstrateETL polkadot xcmtransfers 2022-12-29
//  dump all xcmtransfers in last year: dumpSubstrateETL polkadot xcmtransfers
//  dump account metrics in last year: dumpSubstrateETL polkadot accountmetrics
//  compute xcmteleporfees: dumpSubstrateETL polkadot xcmteleportfees
//  update blocklog: dumpSubstrateETL blocklog
//  update blocklog: dumpSubstrateETL polkaholic

const { Command } = require('commander');
const fs = require('fs');
var SubstrateETL = require("./substrateetl");
var paraTool = require("./paraTool");

class SubstrateETLCLI {
    async accountmetrics(opt) {
        //console.log(o)
        let { relaychain, paraID, logDT } = opt;
        let relayChain = relaychain
        let isRange = (logDT == 'range')? true : false
        let isDryRun = (opt.dry)? true : false
        switch (relaychain) {
            case 'kusama':
            case 'polkadot':
                break;
            default:
                console.log(`Unsupported relaychain ${relaychain}.`)
                return;
        }
        if (!paraTool.isNumeric(paraID) && paraID != 'all'){
            console.log(`Invalid paraID args:${paraID}`)
            return
        }
        var substrateetl = new SubstrateETL();
        if (isRange){
            await substrateetl.dump_account_metrics_range(relayChain, null, paraID, isDryRun);
        }else if (logDT){
            await substrateetl.dump_account_metrics(logDT, relayChain, paraID, isDryRun);
        }else{
            console.log(`logDT missing`)
        }
    }

    async dumpsubstrateetl(opt) {
        //console.log(o)
        let { relaychain, paraID, logDT } = opt;
        let relayChain = relaychain
        let isRange = (logDT == 'range')? true : false
        let isDryRun = (opt.dry)? true : false
        let isEVM = (opt.dry)? true : false
        switch (relaychain) {
            case 'kusama':
                if (paraID == '2007' || paraID == '2023'){
                    isEVM = true
                }
            case 'polkadot':
                if (paraID == '2004' || paraID == '2006'){
                    isEVM = true
                }
                break;
            default:
                console.log(`Unsupported relaychain ${relaychain}.`)
                return;
        }
        if (!paraTool.isNumeric(paraID) && paraID != 'random'){
            console.log(`Invalid paraID args:${paraID}`)
            return
        }
        var substrateetl = new SubstrateETL();
        if (paraID == 'random'){
            let tally = 0;
            while (true) {
                let x = await substrateetl.get_random_substrateetl(logDT, paraID, relayChain);
                let _logDT = x.logDT;
                let _paraID = x.paraID;
                let _relayChain = x.relayChain;
                let _isEVM = x.isEVM;
                if (_logDT && (_paraID >= 0) && _relayChain) {
                    await substrateetl.dump_substrateetl(_logDT, _paraID, _relayChain, _isEVM);
                    await substrateetl.sleep(1000);
                    tally++;
                    if (tally > 20) {
                        await substrateetl.dump_substrateetl_polkaholic()
                        tally = 0;
                    }
                } else {
                    await substrateetl.sleep(10000);
                }
            }
        }else if (isRange){
            //await substrateetl.dump_substrateetl(logDT, parseInt(paraID), relayChain, isEVM);
        }else if (logDT){
            if (paraTool.isNumeric(paraID)){
                await substrateetl.dump_substrateetl(logDT, parseInt(paraID), relayChain, isEVM);
            }else{
                //TODO:
                console.log(`TODO: the all cases`)
            }
        }else{
            console.log(`logDT missing`)
        }
    }

}

async function main() {
    let cli_version = '0.0.1'
    const program = new Command();
    program
	.name('dumpETL')
	.description('dump substrate ETL')
	.version(`${cli_version}`);

    /*
    Dump account metric for a paraID given specific date
    ./dumpETL accountmetrics -r polkadot -p 2004 -dt 20230202

    Dump account metric for relaychain's all paraIDs given specific date
    ./dumpETL accountmetrics -r polkadot -p all -dt 20230202
    */
    program.command('accountmetrics')
	.description('Dump accuntmetric for a chain')
	.option('-r, --relaychain <relaychain>', 'relaychain (polkadot or kusama)', 'polkadot')
    .option('-p, --paraID <paraID>', `Targeted paraID (relaychain itself is identified using paraID=0). If not specified, crawl for all reachable parachains.`, 'all')
    .option('-dt, --logDT <logDT>', `LogDT in YYYYMMDD. If not specified, generate logs for all days since 2023-02-01`, '2023-02-01')
    .option('-d, --dry', `dry run the cmd without updating`, false)
	.action(async (opt) => {
	    let dumpcli = new SubstrateETLCLI();
	    await dumpcli.accountmetrics(opt);
	});


    /*
    dump substrateetl for a random parachain
    ./dumpETL substrateetl -r polkadot

    dump substrateetl for a paraID given specific date
    ./dumpETL substrateetl -r polkadot -p 2004 -dt 20230202

    */
    program.command('substrateetl')
    .description(`Dump substrate etl (blocks, extrinsics, events, transfers, logs) for a chain. Additionally, (evmtxs, evmtransfers) for evm chain`)
    .option('-r, --relaychain <relaychain>', 'relaychain (polkadot or kusama)', 'polkadot')
    .option('-p, --paraID <paraID>', `Targeted paraID (relaychain itself is identified using paraID=0). If not specified, crawl for a random parachains.`, 'random')
    .option('-e, --isEvm', `Flag if it's evm chain`, true)
    .option('-dt, --logDT <logDT>', `LogDT in YYYYMMDD. If not specified, generate logs for all days since 2023-02-01`, '2023-02-01')
    .option('-d, --dry', `dry run the cmd without updating`, false)
    .action(async (opt) => {
        let dumpcli = new SubstrateETLCLI();
        await dumpcli.dumpsubstrateetl(opt);
    });

    await program.parseAsync(process.argv);
}

main()
    .then(() => {
        process.exit(0);
    })
    .catch((e) => {
        console.error('ERROR', e);
        process.exit(1);
    });
